package gomobile_bind

// Go support functions for Objective-C. Note that this
// file is copied into and compiled with the generated
// bindings.

/*
#cgo CFLAGS: -x objective-c -fobjc-arc -Werror
#cgo LDFLAGS: -framework Foundation

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "mochi.h"
*/
import "C"

import (
    "runtime"
    "fmt"
)

type Value struct {
    ref int64
}

//export MochiTest
func MochiTest() C.int {
    value := Root()
    appended := value.Call("uppercaseString", nil)
    s := appended.ToString()
    fmt.Println(s)
    
    _ = Array([]*Value{ 
        String("poo"),
        String("blah"),
    })
    
    v := Float64(34238974)
    blah := v.ToFloat64()
    
    runtime.GC()
    return C.int(blah)
}

func NewValue(ref C.ObjcRef) *Value {
    v := &Value{ ref: int64(ref) }
    runtime.SetFinalizer(v, func(a *Value) {
        C.MochiUntrackObjc(a.Ref())  
    })
    return v
}

func (v *Value)Ref() C.ObjcRef {
    return C.ObjcRef(v.ref)
}

func Root() *Value {
    return NewValue(C.MochiObjcRoot())
}

func Bool(v bool) *Value {
    return NewValue(C.MochiObjcBool(C.bool(v)))
}

func (v *Value)ToBool() bool {
    defer runtime.KeepAlive(v)
    return bool(C.MochiObjcToBool(v.Ref()))
}

func Int64(v int64) *Value {
    return NewValue(C.MochiObjcInt64(C.int64_t(v)))
}

func (v *Value)ToInt64() int64 {
    defer runtime.KeepAlive(v)
    return int64(C.MochiObjcToInt64(v.Ref()))
}

func Float64(v float64) *Value {
    return NewValue(C.MochiObjcFloat64(C.double(v)))
}

func (v *Value)ToFloat64() float64 {
    defer runtime.KeepAlive(v)
    return float64(C.MochiObjcToFloat64(v.Ref()))
}

func String(v string) *Value {
    cstr := cString(v)
    return NewValue(C.MochiObjcString(cstr));
}

func (v *Value)ToString() string {
    defer runtime.KeepAlive(v)
    buf := C.MochiObjcToString(v.Ref())
    return goString(buf)
}

func Bytes(v string) *Value {
    return nil
}

func (v *Value)ToBytes() []byte {
    return nil
}

func Array(a []*Value) *Value {
    ref := C.MochiObjcArray()
    array := NewValue(ref);
    for _, i := range a {
        C.MochiObjcArrayAppend(ref, i.Ref())
    }
    return array
}

func (v *Value)ToArray() []*Value {
    defer runtime.KeepAlive(v)
    ref := v.Ref()
    length := int64(C.MochiObjcArrayLen(v.Ref()))
    slice := make([]*Value, length)
    for i := int64(0); i < length; i++ {
        slice[i] = NewValue(C.MochiObjcArrayAt(ref, C.int64_t(i)))
    }
    return slice
}

func (v *Value)Call(s string, args []*Value) *Value {
    defer runtime.KeepAlive(v)
    
    argsRef := C.ObjcRef(0)
    if len(args) > 0 {
        array := Array(args)
        defer runtime.KeepAlive(array)
        argsRef = array.Ref()
    }
    return NewValue(C.MochiObjcCall(v.Ref(), cString(s), argsRef))
}

func cString(v string) C.CGoBuffer {
    var cstr C.CGoBuffer 
    if len(v) == 0 {
        cstr = C.CGoBuffer{}
    } else {
        cstr = C.CGoBuffer{
            ptr: C.CBytes([]byte(v)),
            len: C.int64_t(len(v)),
        }
    }
    return cstr
}

func goString(buf C.CGoBuffer) string {
    str := C.GoBytes(buf.ptr, C.int(buf.len))
    C.free(buf.ptr)
    return string(str)
}