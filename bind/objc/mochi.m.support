#include <stdio.h>
#include <stdint.h>
#include <string.h>
#import <Foundation/Foundation.h>
#include "mochi.h"

@implementation MochiBridge
+ (id)sharedBridge {
    static MochiBridge *sBridge = nil;
    static dispatch_once_t sOnce;
    dispatch_once (&sOnce, ^{
        sBridge = [[MochiBridge alloc] init];
    });
    return sBridge;
}
@end

@interface MochiTracker : NSObject {
    NSMapTable *_mapTable;
    int64_t _maxKey;
}
@end

@implementation MochiTracker

+ (MochiTracker *)sharedTracker {
    static MochiTracker *sTracker = nil;
    static dispatch_once_t sOnce;
    dispatch_once (&sOnce, ^{
        sTracker = [[MochiTracker alloc] init];
    });
    return sTracker;
}

- (id)init {
    if ((self = [super init])) {
        _mapTable = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsObjectPersonality|NSPointerFunctionsStrongMemory 
            valueOptions:NSPointerFunctionsObjectPersonality|NSPointerFunctionsStrongMemory capacity:0];
        _maxKey = 0;
    }
    return self;
}

- (ObjcRef)track:(id)object {
    if (object == nil) {
        return 0;
    }
    @synchronized (self) {
        _maxKey += 1;
        [_mapTable setObject:object forKey:@(_maxKey)];
        return _maxKey;
    }
}

- (void)untrack:(ObjcRef)key {
    if (key == 0) {
        return;
    }
    @synchronized (self) {
        id keyObj = @(key);
        id object = [_mapTable objectForKey:keyObj];
        if (object == nil) {
            NSLog(@"UntrackError");
            @throw @"Untrack error. No corresponding object for key.";
        }
        [_mapTable removeObjectForKey:keyObj];
    }
}

- (id)get:(ObjcRef)key {
    if (key == 0) {
        return nil;
    }
    @synchronized (self) {
        id object = [_mapTable objectForKey:(id)@(key)];
        if (object == nil) {
            @throw @"Get error. No corresponding object for key";
        }
        return object;
    }
}

@end

ObjcRef MochiObjcRoot() {
    id root = [[MochiBridge sharedBridge] rootObject];
    return MochiTrackObjc(root);
}

ObjcRef MochiObjcBool(bool v) {
    return MochiTrackObjc(@(v));
}

bool MochiObjcToBool(ObjcRef v) {
    NSNumber *val = MochiGetObjc(v);
    return val.boolValue;
}

ObjcRef MochiObjcInt64(int64_t v) {
    return MochiTrackObjc(@(v));
}

int64_t MochiObjcToInt64(ObjcRef v) {
    NSNumber *val = MochiGetObjc(v);
    return val.longLongValue;
}

ObjcRef MochiObjcFloat64(double v) {
    return MochiTrackObjc(@(v));
}

double MochiObjcToFloat64(ObjcRef v) {
    NSNumber *val = MochiGetObjc(v);
    return val.doubleValue;
}

ObjcRef MochiObjcString(CGoBuffer cstr) {
    return MochiTrackObjc(MochiNSString(cstr));
}

CGoBuffer MochiObjcToString(ObjcRef v) {
    NSString *str = MochiGetObjc(v);
    int len = [str lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
    if (len == 0) {
        return (CGoBuffer){0};
    }

    char *buf = (char *)malloc(len);
    assert(buf != NULL);
    [str getBytes:buf maxLength:len usedLength:NULL encoding:NSUTF8StringEncoding options:0 range:NSMakeRange(0, str.length) remainingRange:NULL];
  
    CGoBuffer cstr;
    cstr.ptr = buf;
    cstr.len = len;
    return cstr;
}

ObjcRef MochiObjcBytes(CGoBuffer bytes) {
    if (bytes.len == 0) {
        return MochiTrackObjc([NSData data]);
    }
    NSData *data = [[NSData alloc] initWithBytesNoCopy:bytes.ptr length:bytes.len freeWhenDone:YES];
    return MochiTrackObjc(data);
}

CGoBuffer MochiObjcToBytes(ObjcRef v) {
    NSData *data = MochiGetObjc(v);
    int len = [data length];
    if (len == 0) {
        return (CGoBuffer){0};
    }

    char *buf = (char *)malloc(len);
    assert(buf != NULL);
    [data getBytes:buf length:len];
  
    CGoBuffer cstr;
    cstr.ptr = buf;
    cstr.len = len;
    return cstr;
}

// Array

ObjcRef MochiObjcArray() {
    NSMutableArray *val = [NSMutableArray array];
    return MochiTrackObjc(val);
}

int64_t MochiObjcArrayLen(ObjcRef v) {
    NSMutableArray *val = MochiGetObjc(v);
    return val.count;
}

void MochiObjcArrayAppend(ObjcRef v, ObjcRef a) {
    NSMutableArray *obj = MochiGetObjc(a);
    NSMutableArray *val = MochiGetObjc(v);
    [val addObject:obj];
}

ObjcRef MochiObjcArrayAt(ObjcRef v, int64_t index) {
    NSMutableArray *val = MochiGetObjc(v);
    return MochiTrackObjc(val[index]);
}

// Call

ObjcRef MochiObjcCall(ObjcRef v, CGoBuffer cstr, ObjcRef arguments) {
    id obj = MochiGetObjc(v);
    NSArray *args = MochiGetObjc(arguments);
    SEL sel = NSSelectorFromString(MochiNSString(cstr));
    
    NSMethodSignature *sig = [[obj class] instanceMethodSignatureForSelector:sel];
    
    // Build invocation.
    NSInvocation *inv = [NSInvocation invocationWithMethodSignature:sig];
    inv.selector = sel;
    inv.target = obj;
    for (int i=0; i < args.count; i++) {
        id argObj = args[i];
        NSNumber *num = (NSNumber *)argObj;
        const char *type = sig.methodReturnType;
        
        if (strcmp(type, "c") == 0) {
            char arg = num.charValue;
            [inv setArgument:&arg atIndex:i+2];
        } else if (strcmp(type, "i") == 0) {
            int arg = num.intValue;
            [inv setArgument:&arg atIndex:i+2];
        } else if (strcmp(type, "s") == 0) {
            short arg = num.shortValue;
            [inv setArgument:&arg atIndex:i+2];
        } else if (strcmp(type, "l") == 0) {
            long arg = num.longValue;
            [inv setArgument:&arg atIndex:i+2];
        } else if (strcmp(type, "q") == 0) {
            long long arg = num.longLongValue;
            [inv setArgument:&arg atIndex:i+2];
        } else if (strcmp(type, "C") == 0) {
            unsigned char arg = num.unsignedCharValue;
            [inv setArgument:&arg atIndex:i+2];
        } else if (strcmp(type, "I") == 0) {
            unsigned int arg = num.unsignedIntValue;
            [inv setArgument:&arg atIndex:i+2];
        } else if (strcmp(type, "S") == 0) {
            unsigned short arg = num.unsignedShortValue;
            [inv setArgument:&arg atIndex:i+2];
        } else if (strcmp(type, "L") == 0) {
            unsigned long arg = num.unsignedLongValue;
            [inv setArgument:&arg atIndex:i+2];
        } else if (strcmp(type, "Q") == 0) {
            unsigned long long arg = num.unsignedLongLongValue;
            [inv setArgument:&arg atIndex:i+2];
        }  else if (strcmp(type, "f") == 0) {
            float arg = num.floatValue;
            [inv setArgument:&arg atIndex:i+2];
        } else if (strcmp(type, "d") == 0) {
            double arg = num.doubleValue;
            [inv setArgument:&arg atIndex:i+2];
        } else if (strcmp(type, "B") == 0) {
            bool arg = num.boolValue;
            [inv setArgument:&arg atIndex:i+2];
        } else if (strcmp(type, "@") == 0) {
            [inv setArgument:&argObj atIndex:i+2];
        } else {
            @throw @"MochiObjcCall: Unsupported argument type";
        }
    }
    
    // Invoke.
    [inv invoke];
    
    // Get return value.
    const char *type = [sig methodReturnType];
    id ret = nil;
    if (strcmp(type, "c") == 0 || strcmp(type, "i") == 0 || strcmp(type, "s") == 0 || strcmp(type, "l") == 0 || strcmp(type, "q") == 0
        || strcmp(type, "C") == 0 || strcmp(type, "I") == 0 || strcmp(type, "S") == 0 || strcmp(type, "L") == 0 || strcmp(type, "Q") == 0
        || strcmp(type, "f") == 0 || strcmp(type, "d") == 0 || strcmp(type, "B") == 0) {
        
        void *buf = malloc(sig.methodReturnLength);
        [inv getReturnValue:&buf];
        ret = [[NSNumber alloc] initWithBytes:buf objCType:type];
        free(buf);
    } else if (strcmp(type, "v") == 0) {
        ret = nil;
    } else if (strcmp(type, "@") == 0) {
        void *retValue = nil;
        [inv getReturnValue:&retValue];
        ret = (__bridge id)retValue;
    } else {
        @throw @"MochiObjcCall: Unsupported return type";
    }
    return MochiTrackObjc(ret);
}

// Tracker

ObjcRef MochiTrackObjc(id value) {
    return [[MochiTracker sharedTracker] track:value];
}

id MochiGetObjc(ObjcRef key) {
    return [[MochiTracker sharedTracker] get:key];
}

void MochiUntrackObjc(ObjcRef key) {
    [[MochiTracker sharedTracker] untrack:key];
}

// Utilities

NSString *MochiNSString(CGoBuffer cstr) {
    if (cstr.len == 0) {
        return @"";
    }
    return [[NSString alloc] initWithBytesNoCopy:cstr.ptr length:cstr.len encoding:NSUTF8StringEncoding freeWhenDone:YES];
}
